"""
Algorithm to compute required articles applying the pagerank algorithm to a graph generated by 
tranversing the target article by a few levels.
"""

import sys

import py2neo
from py2neo import Graph

import networkx as nx

import matplotlib.pyplot as plt

print "Initing db..."

#Load database
py2neo.authenticate("localhost:7474", "neo4j", "lucas")
graph = Graph("http://localhost:7474/db/data/")

articleTitle = sys.argv[1]

# #Construct the query
# dbQuery = " ".join([
#     # 'MATCH (n:Article {title:"ARTICLE-TITLE"})-[l:ConnectsTo]->(n1:Article)-[l1:ConnectsTo*1..2]->(n2:Article)',
#     'MATCH (n1:Article {title:"ARTICLE-TITLE"})-[l1:ConnectsTo*1..1]->(n2:Article)',
#     #'OPTIONAL MATCH (n2)-[l2:ConnectsTo]->(n3:Article)',
#     #'WHERE (n1)-[:ConnectsTo*1..1]->(n3)',
#     # 'WHERE n1 <> n2',
#     # 'WHERE (n <> n1 AND n <> n2)',
#     #'RETURN l1 + collect(l2)',
#     'RETURN l1'
# ]).replace("ARTICLE-TITLE", articleTitle)

#Create a directed graph

G = nx.DiGraph()

#Query all nodes id related
dbQuery = " ".join([
    'MATCH (n1:Article {title:"ARTICLE-TITLE"})-[l1:ConnectsTo*1..3]->(n2:Article)',
    'RETURN collect(DISTINCT ID(n1)) + collect(DISTINCT ID(n2)) as ids'
]).replace("ARTICLE-TITLE", articleTitle)

nodeIds = [] #Array to keep node ids

print "Querying ids..."

#Execute query and compute ids
for r in graph.run(dbQuery):
    nodeIds += r['ids']

#Now query all connectTo relations between these nodes
dbQuery = " ".join([
    'MATCH (n1:Article)-[l1:ConnectsTo]-(n2:Article)',
    'WHERE (ID(n1) IN NODE-IDS AND ID(n2) IN NODE-IDS)',
    'RETURN l1 as edges'
]).replace("NODE-IDS", str(nodeIds))

print "Querying edges..."

#Execute query and add edges
for val in graph.run(dbQuery):
    e = val[0]
    G.add_edge(e.start_node()['title'], e.end_node()['title'])

print "" #Skip line

# Must ensure connections between tranversals exists

# keep working on the query

#Execute query 
#iterate over the results
#And add edges
# for r in graph.run(dbQuery):
#     for e in r[0]:
#         G.add_edge(e.start_node()['title'], e.end_node()['title'])
#         # print (e.start_node()['title'], e.end_node()['title'])

print len(G.edges())

print "\n".join(map(str, sorted(nx.pagerank(G).items(), key=lambda a: a[1], reverse=True))) #Pagerank

# for comp in nx.weakly_connected_components(G):
#     print comp

# for e in G.edges():
#     print e


# nx.draw(G)
# plt.show()